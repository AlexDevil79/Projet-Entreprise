"""Generation dictionnaire.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U0gbUgQskp8JtICfauso6mlelKz55U1B

# <Center> Géneration et enristrement du dictionnaire

# But du code: 
Enregistrer sur l'ordinateur l'ensemble des signaux qui sont mis dans un dictionnaire. Deux types de dictionnaire peuvent être généré:
 
Le premier dit sans rsb, où chaque classe (quiest associé à une classe de signal) est une liste comportant des dictionnaires, chacun représentant un signal avec ses informations importantes.
 
Le deuxième lui tri les signaux par rsb, ainsi chaque classe de celui-ci correspond aux signaux ayant une valeur particulière de rsb. Ces classes sont tous des dictionnaires structurés comme le premier.

# Execution du code: 
A part les variables qui sont dans la deuxième cellule (et les noms des fichiers à la toute fin), rien est à modifier et le code peut être exécuté directement. Mais c'est plutôt à éviter car cela enregistrera les deux dictionnaires sur votre ordinateur. Ainsi il est préférable d'exécuter tout ce qui est au-dessus des deux dernières cellules, et ensuite n'enregistrer que le dictionnaire qui vous intéresse. Normalement l'enregistrement se fait là où se situe ce code.

Importation des différents modules python nécessaires
"""

from scipy.io import wavfile
import os
import xml.etree.ElementTree as ET

"""Différentes variables à modifier selon la base de donnée"""
dossier="D:\data_sans_residu\data_sans_residu" #adresse où se trouve la base de donnée sur l'ordinateur, à modifier
list_class=['AM','AM_FSK','AM_PSK','ASK4','FM','FM_FSK','FM_PSK','FSK2','FSK4','GFSK2','GFSK4','OFDM','PI2DPSK2','PI4DPSK4','PSK2','PSK4','QAM16','QAM32','QAM64']
#liste des classes se trouvant dans la base, à changer si celle si change
list_rsb=['rsb_8','rsb_10','rsb_12','rsb_14','rsb_16','rsb_18','rsb_20','rsb_22','rsb_24','rsb_26','rsb_28','rsb_30']
# liste des différents rsb existants, 'rsb_8' correspond ici à 8 dB, de même à modifier selon la base de donnée

"""Initialisation des fonctions nécesssaires au fonctionnement du code"""
def adress_dossier(adresse_dossier): #retourne une liste de toutes les adresses des fichiers se trouvant dans le dossier
    #dossier= os.listdir(adresse_dossier) 
    path =adresse_dossier
    #on initialise une liste pour y mettre toute les adresses
    filelist = []
    for root, dirs, files in os.walk(path):
        for file in files:
            #rajoute l'adresse à la liste
            filelist.append(os.path.join(root,file))
    return filelist

def lire_XML(adress): #prends l'adresse d'un XML en entrée, retourne un dictionnaire avec les différentes informations de ce XML dedans
    tree = ET.parse(adress)
    root = tree.getroot()
    #création du dictionnaire à retourner
    dic={}
    #pour chque information dans l'XML la rajoute au dictionnaire 
    for a in range(len(root)):
        dic[root[a].tag]=root[a].text
    #retourne le dictionnaire avec les infomrations de XML
    return dic

def creer_adresses(adresse_base,list_class):#crée et retourne l'adresse des dossier de chaque classe à l'aide de l'adresse de la base et de la liste des noms des classes
    adresses=[]
    for i in range(len(list_class)):
        adresses.append(adresse_base.__add__('\\').__add__(list_class[i]))
    return adresses

"""Fonctions dictionnaire sans prise en compte du rsb"""
def dic_class(adresse_dossier,adres,dic_final): #prend l'adresse d'une classe et rajoute au dictionnaire final , au bon endroit, le dictionnaire de chaque signal de la classe
    list_adress=adress_dossier(adresse_dossier) #récupère toute les adresses des fichiers dans le dossier de la classe
    n=len(list_adress)//2
    for i in range(n):# Pour chaque signal de la classe lui associe un dictionnaire et le place au bon endroit dans le dictionnaire final
        #crée un dictionnaire avec toute les informations du XML lié à celui-ci
        dic=lire_XML(list_adress[2*i+2])  #!! les indices sont choisit dans le cas où le dossier est de la forme: fichier .wav et en dessous sont fichier XML associé
        # puis rajoute à ce dictionnaire son adresse relative
        dic["file_adress"]=list_adress[2*i+1].split(adres)[1]      
        #récupère la classe du signal à partir de son adresse, étape fait car le 'type_class' dans les XML sont parfois différents du nom de la classe
        adress_signal=list_adress[2*i+1]
        adress_signal=os.path.dirname(adress_signal)
        adress_signal=os.path.dirname(adress_signal)
        class_signal=os.path.basename(adress_signal)
        #ajoute le dictionnaire correspondant au signal à la bonne classe
        dic_final[class_signal].append(dic)

def sol(adresse_base,list_class): #crée le dictionnaire en prenant l'adresse de la base et la liste des classes
    #initialisation du dictionnaire
    dic_base={}
    for i in list_class:
        dic_base[i]=[]  
    # récupère les adresses de chaque classe
    adress_class=creer_adresses(adresse_base,os.listdir(adresse_base))
    #pour chaque classe, parcours toutes les signaux et les classes par classe
    n=len(adress_class)
    for i in range(n):
        dic_class(adress_class[i],adresse_base,dic_base)
    #retourne le dictionnaire final   
    return dic_base

"""Fonctions pour dictionnaire prenant en compte le rsb"""
def dict_rsb(adresse_dossier,adres,dic_final,list_rsb): #prend un l'adresse d'une classe et rajoute au dictionnaire final , au bon endroit (en triant cette fois-ci aussi par rapport au rsb), le dictionnaire de chaque signal de la classe
    list_adress=adress_dossier(adresse_dossier) #récupère toute les adresses des fichiers dans le dossier de la classe
    n=len(list_adress)//2
    for i in range(n): # Pour chaque signal de la classe lui associe un dictionnaire et le place au bon endroit dans le dictionnaire final
        #crée un dictionnaire avec toute les informations du XML lié à celui-ci
        dic=lire_XML(list_adress[2*i+2])  #!!! les indices sont choisit dans le cas où le dossier est de la forme: fichier .wav et en dessous sont fichier XML associé
        # puis rajoute à ce dictionnaire son adresse relative
        dic["file_adress"]=list_adress[2*i+1].split(adres)[1]
        rsb='rsb_'+dic['rsb_dB'] #crée un string type 'rsb_8'ou 'rsb_10'... correspondant à la valeur du rsb en dB, afin de classer dans la bonne classe de rsb plus bas
        #récupère la classe du signal à partir de son adresse, étape fait car le 'type_class' dans les XML sont parfois différents du nom de la classe
        adress_signal=list_adress[2*i+1]
        adress_signal=os.path.dirname(adress_signal)
        adress_signal=os.path.dirname(adress_signal)
        class_signal=os.path.basename(adress_signal)
        #ajoute le dictionnaire correspondant au signal au bon rsb et à la bonne classe
        (dic_final[rsb])[class_signal].append(dic)

def sol_rsb(adresse_base,list_class,list_rsb): #crée le dictionnaire en prenant l'adresse de la base et la liste des classes
    #initialisation du dictionnaire
    dic_rsb={}
    for i in list_rsb:
        dic_rsb[i]={}
        for j in list_class:
            (dic_rsb[i])[j]=[]
    # récupère les adresses de chaque classe
    adress_class=creer_adresses(adresse_base,os.listdir(adresse_base))
    #pour chaque classe, parcours toutes les signaux et les classes par rsb, puis par classe
    n=len(adress_class)
    for i in range(n):
        dict_rsb(adress_class[i],adresse_base,dic_rsb,list_rsb)
    #retourne le dictionnaire final    
    return dic_rsb

"""
Création des dictionnaires
Création du dictionnaire sans prise en compte du rsb
"""

dic=sol(dossier,list_class)

"""Création du dictionnaire en prenant compte du rsb"""

dic_rs=sol_rsb(dossier,list_class,list_rsb)

"""
Création des Json pour les enregistrer sur l'ordinateur
Création et enregistrement du json sans rsb sur l'ordinateur
"""

import json
nom_fichier="base_sans_rsb.json" #nom du fichier sur l'ordinateur, à modifier selon préférance
with open(nom_fichier,"w") as write_file:
    json.dump(dic_rs, write_file)

"""Création et enregistrement du json sans rsb sur l'ordinateur"""

nom_fichier_rsb="base_avec_rsb.json" #nom du fichier sur l'ordinateur, à modifier selon préférance
with open(nom_fichier_rsb,"w") as write_file:
    json.dump(dic_rs, write_file)